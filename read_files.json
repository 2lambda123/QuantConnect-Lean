{"files":[{"id":57518611,"name":"algorithm.cs","content":"\/*\r\n * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.\r\n * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n*\/\r\n\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing QuantConnect.Data;\r\nusing QuantConnect.Data.Market;\r\nusing QuantConnect.Indicators;\r\n\r\nnamespace QuantConnect.Algorithm.CSharp\r\n{\r\n    \/\/\/ &lt;summary&gt;\r\n    \/\/\/ Strategy example algorithm using CAPE - a bubble indicator dataset saved in dropbox. CAPE is based on a macroeconomic indicator(CAPE Ratio),\r\n    \/\/\/ we are looking for entry\/exit points for momentum stocks CAPE data: January 1990 - December 2014\r\n    \/\/\/ Goals:\r\n    \/\/\/ Capitalize in overvalued markets by generating returns with momentum and selling before the crash\r\n    \/\/\/ Capitalize in undervalued markets by purchasing stocks at bottom of trough\r\n    \/\/\/ &lt;\/summary&gt;\r\n    \/\/\/ &lt;meta name=&quot;tag&quot; content=&quot;strategy example&quot; \/&gt;\r\n    \/\/\/ &lt;meta name=&quot;tag&quot; content=&quot;custom data&quot; \/&gt;\r\n    public class BubbleAlgorithm : QCAlgorithm\r\n    {\r\n        private decimal _currCape;\r\n        private readonly decimal[] _c = new decimal[4];\r\n        private readonly decimal[] _cCopy = new decimal[4];\r\n        private bool _newLow;\r\n        private int _counter;\r\n        private int _counter2;\r\n        private MovingAverageConvergenceDivergence _macd;\r\n        private RelativeStrengthIndex _rsi = new RelativeStrengthIndex(14);\r\n        private readonly ArrayList _symbols = new ArrayList();\r\n        private readonly Dictionary&lt;string, RelativeStrengthIndex&gt; _rsiDic = new Dictionary&lt;string, RelativeStrengthIndex&gt;();\r\n        private readonly Dictionary&lt;string, MovingAverageConvergenceDivergence&gt; _macdDic = new Dictionary&lt;string, MovingAverageConvergenceDivergence&gt;();\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Called at the start of your algorithm to setup your requirements:\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public override void Initialize()\r\n        {\r\n            SetCash(100000);\r\n            _symbols.Add(&quot;SPY&quot;);\r\n            SetStartDate(1998, 1, 1);\r\n            SetEndDate(2014, 6, 1);\r\n\r\n            \/\/Present Social Media Stocks:\r\n            \/\/ symbols.Add(&quot;FB&quot;);symbols.Add(&quot;LNKD&quot;);symbols.Add(&quot;GRPN&quot;);symbols.Add(&quot;TWTR&quot;);\r\n            \/\/ SetStartDate(2011, 1, 1);\r\n            \/\/ SetEndDate(2014, 12, 1);\r\n\r\n            \/\/2008 Financials:\r\n            \/\/ symbols.Add(&quot;C&quot;);symbols.Add(&quot;AIG&quot;);symbols.Add(&quot;BAC&quot;);symbols.Add(&quot;HBOS&quot;);\r\n            \/\/ SetStartDate(2003, 1, 1);\r\n            \/\/ SetEndDate(2011, 1, 1);\r\n\r\n            \/\/2000 Dot.com:\r\n            \/\/ symbols.Add(&quot;IPET&quot;);symbols.Add(&quot;WBVN&quot;);symbols.Add(&quot;GCTY&quot;);\r\n            \/\/ SetStartDate(1998, 1, 1);\r\n            \/\/ SetEndDate(2000, 1, 1);\r\n\r\n            \/\/CAPE data\r\n            AddData&lt;CAPE&gt;(&quot;CAPE&quot;);\r\n\r\n            foreach (string stock in _symbols)\r\n            {\r\n                AddSecurity(SecurityType.Equity, stock, Resolution.Minute);\r\n\r\n                _macd = MACD(stock, 12, 26, 9, MovingAverageType.Exponential, Resolution.Daily);\r\n                _macdDic.Add(stock, _macd);\r\n                _rsi = RSI(stock, 14, MovingAverageType.Exponential, Resolution.Daily);\r\n                _rsiDic.Add(stock, _rsi);\r\n\r\n                Securities[stock].SetLeverage(10);\r\n            }\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Trying to find if current Cape is the lowest Cape in three months to indicate selling period\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public void OnData(CAPE data)\r\n        {\r\n            _newLow = false;\r\n            \/\/Adds first four Cape Ratios to array c\r\n            _currCape = data.Cape;\r\n            if (_counter &lt; 4)\r\n            {\r\n                _c[_counter++] = _currCape;\r\n            }\r\n            \/\/Replaces oldest Cape with current Cape\r\n            \/\/Checks to see if current Cape is lowest in the previous quarter\r\n            \/\/Indicating a sell off\r\n            else\r\n            {\r\n                Array.Copy(_c, _cCopy, 4);\r\n                Array.Sort(_cCopy);\r\n                if (_cCopy[0] &gt; _currCape) _newLow = true;\r\n                _c[_counter2++] = _currCape;\r\n                if (_counter2 == 4) _counter2 = 0;\r\n            }\r\n\r\n            Debug(&quot;Current Cape: &quot; + _currCape + &quot; on &quot; + data.Time);\r\n            if (_newLow) Debug(&quot;New Low has been hit on &quot; + data.Time);\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ New TradeBar data for our assets.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public void OnData(TradeBars data)\r\n        {\r\n            try\r\n            {\r\n                \/\/Bubble territory\r\n                if (_currCape &gt; 20 &amp;&amp; _newLow == false)\r\n                {\r\n                    foreach (string stock in _symbols)\r\n                    {\r\n                        \/\/Order stock based on MACD\r\n                        \/\/During market hours, stock is trading, and sufficient cash\r\n                        if (Securities[stock].Holdings.Quantity == 0 &amp;&amp; _rsiDic[stock] &lt; 70\r\n                            &amp;&amp; Securities[stock].Price != 0 &amp;&amp; Portfolio.Cash &gt; Securities[stock].Price * 100\r\n                            &amp;&amp; Time.Hour == 9 &amp;&amp; Time.Minute == 31)\r\n                        {\r\n                            Buy(stock);\r\n                        }\r\n                        \/\/Utilize RSI for overbought territories and liquidate that stock\r\n                        if (_rsiDic[stock] &gt; 70 &amp;&amp; Securities[stock].Holdings.Quantity &gt; 0\r\n                                &amp;&amp; Time.Hour == 9 &amp;&amp; Time.Minute == 31)\r\n                        {\r\n                            Sell(stock);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \/\/ Undervalued territory\r\n                else if (_newLow)\r\n                {\r\n                    foreach (string stock in _symbols)\r\n                    {\r\n\r\n                        \/\/Sell stock based on MACD\r\n                        if (Securities[stock].Holdings.Quantity &gt; 0 &amp;&amp; _rsiDic[stock] &gt; 30\r\n                            &amp;&amp; Time.Hour == 9 &amp;&amp; Time.Minute == 31)\r\n                        {\r\n                            Sell(stock);\r\n                        }\r\n                        \/\/Utilize RSI and MACD to understand oversold territories\r\n                        else if (Securities[stock].Holdings.Quantity == 0 &amp;&amp; _rsiDic[stock] &lt; 30\r\n                            &amp;&amp; Securities[stock].Price != 0 &amp;&amp; Portfolio.Cash &gt; Securities[stock].Price * 100\r\n                            &amp;&amp; Time.Hour == 9 &amp;&amp; Time.Minute == 31)\r\n                        {\r\n                            Buy(stock);\r\n                        }\r\n                    }\r\n\r\n                }\r\n                \/\/ Cape Ratio is missing from original data\r\n                \/\/ Most recent cape data is most likely to be missing\r\n                else if (_currCape == 0)\r\n                {\r\n                    Debug(&quot;Exiting due to no CAPE!&quot;);\r\n                    Quit(&quot;CAPE ratio not supplied in data, exiting.&quot;);\r\n                }\r\n            }\r\n            catch (Exception err)\r\n            {\r\n                Error(err.Message);\r\n            }\r\n        }\r\n\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Buy this symbol\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public void Buy(string symbol)\r\n        {\r\n            var s = Securities[symbol].Holdings;\r\n            if (_macdDic[symbol] &gt; 0m)\r\n            {\r\n                SetHoldings(symbol, 1);\r\n\r\n                Debug(&quot;Purchasing: &quot; + symbol + &quot;   MACD: &quot; + _macdDic[symbol] + &quot;   RSI: &quot; + _rsiDic[symbol]\r\n                    + &quot;   Price: &quot; + Math.Round(Securities[symbol].Price, 2) + &quot;   Quantity: &quot; + s.Quantity);\r\n            }\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Sell this symbol\r\n        \/\/\/ &lt;\/summary&gt;\r\n        \/\/\/ &lt;param name=&quot;symbol&quot;&gt;&lt;\/param&gt;\r\n        public void Sell(string symbol)\r\n        {\r\n            var s = Securities[symbol].Holdings;\r\n            if (s.Quantity &gt; 0 &amp;&amp; _macdDic[symbol] &lt; 0m)\r\n            {\r\n                Liquidate(symbol);\r\n\r\n                Debug(&quot;Selling: &quot; + symbol + &quot; at sell MACD: &quot; + _macdDic[symbol] + &quot;   RSI: &quot; + _rsiDic[symbol]\r\n                    + &quot;   Price: &quot; + Math.Round(Securities[symbol].Price, 2) + &quot;   Profit from sale: &quot; + s.LastTradeProfit);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/\/ &lt;summary&gt;\r\n    \/\/\/ CAPE Ratio for SP500 PE Ratio for avg inflation adjusted earnings for previous ten years\r\n    \/\/\/ Custom Data from DropBox\r\n    \/\/\/ Original Data from: http:\/\/www.econ.yale.edu\/~shiller\/data.htm\r\n    \/\/\/ &lt;\/summary&gt;\r\n    public class CAPE : BaseData\r\n    {\r\n        public decimal Cape;\r\n        private const string Format = &quot;yyyy-MM&quot;;\r\n        private readonly CultureInfo _provider = CultureInfo.InvariantCulture;\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Initializes a new instance of the &lt;see cref=&quot;CAPE&quot;\/&gt; indicator.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public CAPE()\r\n        {\r\n            Symbol = &quot;CAPE&quot;;\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Return the URL string source of the file. This will be converted to a stream\r\n        \/\/\/ &lt;\/summary&gt;\r\n        \/\/\/ &lt;param name=&quot;config&quot;&gt;Configuration object&lt;\/param&gt;\r\n        \/\/\/ &lt;param name=&quot;date&quot;&gt;Date of this source file&lt;\/param&gt;\r\n        \/\/\/ &lt;param name=&quot;isLiveMode&quot;&gt;true if we&#39;re in live mode, false for backtesting mode&lt;\/param&gt;\r\n        \/\/\/ &lt;returns&gt;String URL of source file.&lt;\/returns&gt;\r\n        public override SubscriptionDataSource GetSource(SubscriptionDataConfig config, DateTime date, bool isLiveMode)\r\n        {\r\n            \/\/ Remember to add the &quot;?dl=1&quot; for dropbox links\r\n            return new SubscriptionDataSource(&quot;https:\/\/www.dropbox.com\/s\/ggt6blmib54q36e\/CAPE.csv?dl=1&quot;, SubscriptionTransportMedium.RemoteFile);\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Reader Method :: using set of arguments we specify read out type. Enumerate\r\n        \/\/\/ until the end of the data stream or file. E.g. Read CSV file line by line and convert\r\n        \/\/\/ into data types.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        \/\/\/ &lt;returns&gt;BaseData type set by Subscription Method.&lt;\/returns&gt;\r\n        \/\/\/ &lt;param name=&quot;config&quot;&gt;Config.&lt;\/param&gt;\r\n        \/\/\/ &lt;param name=&quot;line&quot;&gt;Line.&lt;\/param&gt;\r\n        \/\/\/ &lt;param name=&quot;date&quot;&gt;Date.&lt;\/param&gt;\r\n        \/\/\/ &lt;param name=&quot;isLiveMode&quot;&gt;true if we&#39;re in live mode, false for backtesting mode&lt;\/param&gt;\r\n        public override BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, bool isLiveMode)\r\n        {\r\n            var index = new CAPE();\r\n\r\n            try\r\n            {\r\n                \/\/Example File Format:\r\n                \/\/Date   |  Price |  Div  | Earning | CPI  | FractionalDate | Interest Rate | RealPrice | RealDiv | RealEarnings | CAPE\r\n                \/\/2014.06  1947.09  37.38   103.12   238.343    2014.37          2.6           1923.95     36.94        101.89     25.55\r\n                var data = line.Split(&#39;,&#39;);\r\n                \/\/Dates must be in the format YYYY-MM-DD. If your data source does not have this format, you must use\r\n                \/\/DateTime.ParseExact() and explicit declare the format your data source has.\r\n                var dateString = data[0];\r\n                index.Time = DateTime.ParseExact(dateString, Format, _provider);\r\n                index.Cape = Convert.ToDecimal(data[10], CultureInfo.InvariantCulture);\r\n                index.Symbol = &quot;CAPE&quot;;\r\n                index.Value = index.Cape;\r\n            }\r\n            catch\r\n            {\r\n\r\n            }\r\n            return index;\r\n        }\r\n    }\r\n}","modified":"2024-03-26 13:18:55","projectId":17481097,"open":0,"isLibrary":false,"collaborationId":"P17481097-5a6a7-907e1-5c22b-bb89a","userHasAccess":true,"readOnly":false},{"id":57518362,"name":"Main.cs","content":"#region imports\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Globalization;\n    using System.Drawing;\n    using QuantConnect;\n    using QuantConnect.Algorithm.Framework;\n    using QuantConnect.Algorithm.Framework.Selection;\n    using QuantConnect.Algorithm.Framework.Alphas;\n    using QuantConnect.Algorithm.Framework.Portfolio;\n    using QuantConnect.Algorithm.Framework.Execution;\n    using QuantConnect.Algorithm.Framework.Risk;\n    using QuantConnect.Algorithm.Selection;\n    using QuantConnect.Parameters;\n    using QuantConnect.Benchmarks;\n    using QuantConnect.Brokerages;\n    using QuantConnect.Util;\n    using QuantConnect.Interfaces;\n    using QuantConnect.Algorithm;\n    using QuantConnect.Indicators;\n    using QuantConnect.Data;\n    using QuantConnect.Data.Consolidators;\n    using QuantConnect.Data.Custom;\n    using QuantConnect.DataSource;\n    using QuantConnect.Data.Fundamental;\n    using QuantConnect.Data.Market;\n    using QuantConnect.Data.UniverseSelection;\n    using QuantConnect.Notifications;\n    using QuantConnect.Orders;\n    using QuantConnect.Orders.Fees;\n    using QuantConnect.Orders.Fills;\n    using QuantConnect.Orders.Slippage;\n    using QuantConnect.Scheduling;\n    using QuantConnect.Securities;\n    using QuantConnect.Securities.Equity;\n    using QuantConnect.Securities.Future;\n    using QuantConnect.Securities.Option;\n    using QuantConnect.Securities.Forex;\n    using QuantConnect.Securities.Crypto;   \n    using QuantConnect.Securities.Interfaces;\n    using QuantConnect.Storage;\n    using QCAlgorithmFramework = QuantConnect.Algorithm.QCAlgorithm;\n    using QCAlgorithmFrameworkBridge = QuantConnect.Algorithm.QCAlgorithm;\n#endregion\nnamespace QuantConnect.Algorithm.CSharp\n{\n    public class TestProject : QCAlgorithm\n    {\n\n        public override void Initialize()\n        {\n            SetStartDate(2022, 9, 25);\n            SetCash(100000);\n            \n            AddEquity(\"SPY\", Resolution.Minute);\n            AddEquity(\"BND\", Resolution.Minute);\n            AddEquity(\"AAPL\", Resolution.Minute);\n\n        }\n\n        \/\/\/ OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\n        \/\/\/ Slice object keyed by symbol containing the stock data\n        public override void OnData(Slice data)\n        {\n            if (!Portfolio.Invested)\n            {\n                SetHoldings(\"SPY\", 0.33);\n                SetHoldings(\"BND\", 0.33);\n                SetHoldings(\"AAPL\", 0.33);\n            }\n        }\n\n    }\n}","modified":"2024-03-26 13:13:11","projectId":17481097,"open":1,"isLibrary":false,"collaborationId":"P17481097-d8ad6-15fe0-a8c31-4b750","userHasAccess":true,"readOnly":false},{"id":57518363,"name":"Research.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"![QuantConnect Logo](https:\/\/cdn.quantconnect.com\/web\/i\/icon.png)\\n\",\n    \"<hr>\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Research to Production\\n\",\n    \"## Uncorrelated Assets\\n\",\n    \"---------\\n\",\n    \"### Introduction\\n\",\n    \"This page explains how to you can use the Research Environment to develop and test a Uncorrelated Assets hypothesis, then put the hypothesis in production.\\n\",\n    \"<a href=\\\"https:\/\/www.quantconnect.com\/docs\/v2\/research-environment\/tutorials\/research-to-production\/uncorrelated-assets\\\">Documentation<\/a>\\n\",\n    \"\\n\",\n    \"### Create Hypothesis\\n\",\n    \"According to Modern Portfolio Thoery, asset combinations with negative or very low correlation could have lower total portfolio variance given the same level of return. Thus, uncorrelated assets allows you to find a portfolio that will, theoretically, be more diversified and resilient to extreme market events. We're testing this statement in real life scenario, while hypothesizing a portfolio with uncorrelated assets could be a consistent portfolio. In this example, we'll compare the performance of 5-least-correlated-asset portfolio (proposed) and 5-most-correlated-asset portfolio (benchmark), both equal weighting.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Import Libraries\\n\",\n    \"Load the required assembly files and data types.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 1,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"\/\/ We need to load assemblies at the start in their own cell\\n\",\n    \"#load \\\"..\/Initialize.csx\\\"\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 2,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"\/\/ Initialize Lean Engine.\\n\",\n    \"#load \\\"..\/QuantConnect.csx\\\"\\n\",\n    \"\\n\",\n    \"using QuantConnect;\\n\",\n    \"using QuantConnect.Data;\\n\",\n    \"using QuantConnect.Data.Market;\\n\",\n    \"using QuantConnect.Algorithm;\\n\",\n    \"using QuantConnect.Research;\\n\",\n    \"using System;\\n\",\n    \"using System.Linq;\\n\",\n    \"using Accord.Statistics;\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Get Historical Data\\n\",\n    \"To begin, we retrieve historical data for researching.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"\/\/ Instantiate a QuantBook\\n\",\n    \"var qb = new QuantBook();\\n\",\n    \"\\n\",\n    \"\/\/ Select the desired tickers for research.\\n\",\n    \"var assets = new List<string>() {\\\"SHY\\\", \\\"TLT\\\", \\\"SHV\\\", \\\"TLH\\\", \\\"EDV\\\", \\\"BIL\\\",\\n\",\n    \"                              \\\"SPTL\\\", \\\"TBT\\\", \\\"TMF\\\", \\\"TMV\\\", \\\"TBF\\\", \\\"VGSH\\\", \\\"VGIT\\\",\\n\",\n    \"                              \\\"VGLT\\\", \\\"SCHO\\\", \\\"SCHR\\\", \\\"SPTS\\\", \\\"GOVT\\\"};\\n\",\n    \"\\n\",\n    \"\/\/ Call the AddEquity method with the tickers, and their corresponding resolution.\\n\",\n    \"foreach(var ticker in assets){\\n\",\n    \"    qb.AddEquity(ticker, Resolution.Minute);\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"\/\/ Call the History method with qb.Securities.Keys for all tickers, time argument(s), and resolution to request historical data for the symbol.\\n\",\n    \"var history = qb.History(qb.Securities.Keys, new DateTime(2021, 1, 1), new DateTime(2021, 12, 31), Resolution.Daily);\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Preparing Data\\n\",\n    \"We'll have to process our data to get their correlation and select the least related ones.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 4,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"\/\/ Extract daily return for each Symbol from Slice data\\n\",\n    \"var returns = new Dictionary<string, List<Double>>();\\n\",\n    \"var last = new Dictionary<string, Double>();\\n\",\n    \"foreach(var slice in history){\\n\",\n    \"    foreach(var symbol in slice.Bars.Keys){\\n\",\n    \"        if(!returns.ContainsKey(symbol)){\\n\",\n    \"            returns.Add(symbol, new List<Double>());\\n\",\n    \"            last.Add(symbol, (Double)slice.Bars[symbol].Close);\\n\",\n    \"        }\\n\",\n    \"        var change = (Double) ((Double)slice.Bars[symbol].Close - last[symbol])\/last[symbol];\\n\",\n    \"        last[symbol] = (Double)slice.Bars[symbol].Close;\\n\",\n    \"        returns[symbol].Add(change);\\n\",\n    \"    }    \\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"\/\/ Convert returns into 2-d array\\n\",\n    \"double[,] ret = new double[returns.Values.ElementAt(0).Count - 1, assets.Count];\\n\",\n    \"int k = 0;\\n\",\n    \"foreach(var kvp in returns)\\n\",\n    \"{\\n\",\n    \"    var symbol = kvp.Key;\\n\",\n    \"    for(int i=0; i < returns[symbol].Count - 1; i++)\\n\",\n    \"    {\\n\",\n    \"        ret[i, k] = returns[symbol][i + 1];\\n\",\n    \"    }\\n\",\n    \"    k++;\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"\/\/ Write a function to obtain the least and most correlated 5 assets.\\n\",\n    \"public Dictionary<string, Double> GetCorrelations(double[,] returns){\\n\",\n    \"    \/\/ Get correlation matrix\\n\",\n    \"    var corrMatrix = Measures.Correlation(ret);\\n\",\n    \"    \\n\",\n    \"    \/\/ Find the absolute sum correlation of the assets\\n\",\n    \"    var correlations = new Dictionary<string, Double>();\\n\",\n    \"    for(int i=0; i < corrMatrix.GetLength(0); i++)\\n\",\n    \"    {\\n\",\n    \"        var symbol = assets[i];\\n\",\n    \"        if(!correlations.ContainsKey(symbol)){\\n\",\n    \"            correlations.Add(symbol, 0);\\n\",\n    \"        }\\n\",\n    \"        for (int j=0; j < corrMatrix.GetLength(1); j++)\\n\",\n    \"        {\\n\",\n    \"            var value_ = corrMatrix[i, j];\\n\",\n    \"            correlations[symbol] += value_ >= 0 ? value_ : -value_;\\n\",\n    \"        }\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    return correlations;\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"var corr = GetCorrelations(ret);\\n\",\n    \"var selected = corr.OrderBy(x => x.Value).Take(5);\\n\",\n    \"var benchmark = corr.OrderBy(x => x.Value).TakeLast(5);\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Test the Hypothesis\\n\",\n    \"To test the hypothesis: Our desired outcome would be a consistent and low fluctuation equity curve should be seen, as compared with benchmark.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 5,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"\/\/ Construct an equal weighting portfolio for the 5-uncorrelated-asset-portfolio and the 5-correlated-asset-portfolio (benchmark).\\n\",\n    \"double[,] portRet = new double[returns.Values.ElementAt(0).Count, 5];\\n\",\n    \"int j = 0;\\n\",\n    \"foreach(var kvp in selected){\\n\",\n    \"    var symbol = kvp.Key;\\n\",\n    \"    for(int i=0; i < returns[symbol].Count; i++)\\n\",\n    \"    {\\n\",\n    \"        portRet[i, j] = returns[symbol][i] \/ 5;\\n\",\n    \"    }\\n\",\n    \"    j++;\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"double[,] benchRet = new double[returns.Values.ElementAt(0).Count, 5];\\n\",\n    \"j = 0;\\n\",\n    \"foreach(var kvp in benchmark){\\n\",\n    \"    var symbol = kvp.Key;\\n\",\n    \"    for(int i=0; i < returns[symbol].Count; i++)\\n\",\n    \"    {\\n\",\n    \"        benchRet[i, j] = returns[symbol][i] \/ 5;\\n\",\n    \"    }\\n\",\n    \"    j++;\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"\/\/ Get the Equity Return of both portfolios.\\n\",\n    \"var totalValue = new List<double>{1.0};\\n\",\n    \"var dailySum = 0.0;\\n\",\n    \"for(int i=0; i < portRet.GetLength(0); i++)\\n\",\n    \"{\\n\",\n    \"    totalValue.Add(totalValue.Last() * (1 + dailySum));\\n\",\n    \"    dailySum = 0.0;\\n\",\n    \"    for (int j=0; j < portRet.GetLength(1); j++)\\n\",\n    \"    {\\n\",\n    \"        if (double.IsFinite(portRet[i, j]))\\n\",\n    \"        {\\n\",\n    \"            dailySum += portRet[i, j];\\n\",\n    \"        }\\n\",\n    \"    }\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"var totalValueBench = new List<double>{1.0};\\n\",\n    \"var dailySumBench = 0.0;\\n\",\n    \"for(int i=0; i < benchRet.GetLength(0); i++)\\n\",\n    \"{\\n\",\n    \"    totalValueBench.Add(totalValueBench.Last() * (1 + dailySumBench));\\n\",\n    \"    dailySumBench = 0.0;\\n\",\n    \"    for (int j=0; j < benchRet.GetLength(1); j++)\\n\",\n    \"    {\\n\",\n    \"        if (double.IsFinite(benchRet[i, j]))\\n\",\n    \"        {\\n\",\n    \"            dailySumBench += benchRet[i, j];\\n\",\n    \"        }\\n\",\n    \"    }\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"\/\/ Calculate the variance of the 2 portfolios\\n\",\n    \"var returnPort = new List<double>();\\n\",\n    \"var previous = 0.0;\\n\",\n    \"for(int i=0; i < totalValue.Count; i++)\\n\",\n    \"{\\n\",\n    \"    var current = totalValue[i];\\n\",\n    \"    returnPort.Add((current - previous) \/ previous);\\n\",\n    \"    previous = current;\\n\",\n    \"}\\n\",\n    \"var varPort = Math.Sqrt(returnPort.Skip(1).Average(v=>Math.Pow(v-returnPort.Skip(1).Average(),2)));\\n\",\n    \"\\n\",\n    \"var returnBench = new List<double>();\\n\",\n    \"previous = 0.0;\\n\",\n    \"for(int i=0; i < totalValueBench.Count; i++)\\n\",\n    \"{\\n\",\n    \"    var current = totalValueBench[i];\\n\",\n    \"    returnBench.Add((current - previous) \/ previous);\\n\",\n    \"    previous = current;\\n\",\n    \"}\\n\",\n    \"var varBench = Math.Sqrt(returnBench.Skip(1).Average(v=>Math.Pow(v-returnBench.Skip(1).Average(),2)));\\n\",\n    \"\\n\",\n    \"\/\/ Print the result.\\n\",\n    \"Console.WriteLine(\\\"Portfolio Return: {0}, Variance: {1}\\\", (totalValue.Last() - totalValue.First())\/totalValue.First(), varPort);\\n\",\n    \"Console.WriteLine(\\\"Benchmark Return: {0}, Variance: {1}\\\", (totalValueBench.Last() - totalValueBench.First())\/totalValueBench.First(), varBench);\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"We can clearly see from the results, the proposed uncorrelated-asset-portfolio has a lower variance\/fluctuation, thus more consistent than the benchmark. This proven our hypothesis. Moreover, it even out-compete the benchmark.\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \".NET (C#)\",\n   \"language\": \"C#\",\n   \"name\": \"csharp\"\n  },\n  \"language_info\": {\n   \"file_extension\": \".cs\",\n   \"mimetype\": \"text\/x-csharp\",\n   \"name\": \"C#\",\n   \"pygments_lexer\": \"csharp\",\n   \"version\": \"9.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 2\n}","modified":"2024-03-26 13:13:11","projectId":17481097,"open":0,"isLibrary":false,"collaborationId":"P17481097-7faa0-15fe0-9a5a9-2e692","userHasAccess":true,"readOnly":false},{"id":57518372,"name":"main.cs","content":"\/*\r\n * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.\r\n * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n*\/\r\n\r\nusing System.Collections.Generic;\r\nusing QuantConnect.Data;\r\nusing QuantConnect.Interfaces;\r\n\r\nnamespace QuantConnect.Algorithm.CSharp\r\n{\r\n    \/\/\/ &lt;summary&gt;\r\n    \/\/\/ Basic template algorithm simply initializes the date range and cash. This is a skeleton\r\n    \/\/\/ framework you can use for designing an algorithm.\r\n    \/\/\/ &lt;\/summary&gt;\r\n    \/\/\/ &lt;meta name=&quot;tag&quot; content=&quot;using data&quot; \/&gt;\r\n    \/\/\/ &lt;meta name=&quot;tag&quot; content=&quot;using quantconnect&quot; \/&gt;\r\n    \/\/\/ &lt;meta name=&quot;tag&quot; content=&quot;trading and orders&quot; \/&gt;\r\n    public class BasicTemplateAlgorithm : QCAlgorithm, IRegressionAlgorithmDefinition\r\n    {\r\n        private Symbol _spy = QuantConnect.Symbol.Create(&quot;SPY&quot;, SecurityType.Equity, Market.USA);\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public override void Initialize()\r\n        {\r\n            SetStartDate(2013, 10, 07);  \/\/Set Start Date\r\n            SetEndDate(2013, 10, 11);    \/\/Set End Date\r\n            SetCash(100000);             \/\/Set Strategy Cash\r\n\r\n            \/\/ Find more symbols here: http:\/\/quantconnect.com\/data\r\n            \/\/ Forex, CFD, Equities Resolutions: Tick, Second, Minute, Hour, Daily.\r\n            \/\/ Futures Resolution: Tick, Second, Minute\r\n            \/\/ Options Resolution: Minute Only.\r\n            AddEquity(&quot;SPY&quot;, Resolution.Minute);\r\n\r\n            \/\/ There are other assets with similar methods. See &quot;Selecting Options&quot; etc for more details.\r\n            \/\/ AddFuture, AddForex, AddCfd, AddOption\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        \/\/\/ &lt;param name=&quot;data&quot;&gt;Slice object keyed by symbol containing the stock data&lt;\/param&gt;\r\n        public override void OnData(Slice data)\r\n        {\r\n            if (!Portfolio.Invested)\r\n            {\r\n                SetHoldings(_spy, 1);\r\n                Debug(&quot;Purchased Stock&quot;);\r\n            }\r\n        }\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ This is used by the regression test system to indicate if the open source Lean repository has the required data to run this algorithm.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public bool CanRunLocally { get; } = true;\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ This is used by the regression test system to indicate which languages this algorithm is written in.\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public Language[] Languages { get; } = { Language.CSharp, Language.Python };\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Data Points count of all timeslices of algorithm\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public long DataPoints =&gt; 3943;\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ Data Points count of the algorithm history\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public int AlgorithmHistoryDataPoints =&gt; 0;\r\n\r\n        \/\/\/ &lt;summary&gt;\r\n        \/\/\/ This is used by the regression test system to indicate what the expected statistics are from running the algorithm\r\n        \/\/\/ &lt;\/summary&gt;\r\n        public Dictionary&lt;string, string&gt; ExpectedStatistics =&gt; new Dictionary&lt;string, string&gt;\r\n        {\r\n            {&quot;Total Orders&quot;, &quot;1&quot;},\r\n            {&quot;Average Win&quot;, &quot;0%&quot;},\r\n            {&quot;Average Loss&quot;, &quot;0%&quot;},\r\n            {&quot;Compounding Annual Return&quot;, &quot;271.453%&quot;},\r\n            {&quot;Drawdown&quot;, &quot;2.200%&quot;},\r\n            {&quot;Expectancy&quot;, &quot;0&quot;},\r\n            {&quot;Net Profit&quot;, &quot;1.692%&quot;},\r\n            {&quot;Sharpe Ratio&quot;, &quot;8.854&quot;},\r\n            {&quot;Sortino Ratio&quot;, &quot;0&quot;},\r\n            {&quot;Probabilistic Sharpe Ratio&quot;, &quot;67.609%&quot;},\r\n            {&quot;Loss Rate&quot;, &quot;0%&quot;},\r\n            {&quot;Win Rate&quot;, &quot;0%&quot;},\r\n            {&quot;Profit-Loss Ratio&quot;, &quot;0&quot;},\r\n            {&quot;Alpha&quot;, &quot;-0.005&quot;},\r\n            {&quot;Beta&quot;, &quot;0.996&quot;},\r\n            {&quot;Annual Standard Deviation&quot;, &quot;0.222&quot;},\r\n            {&quot;Annual Variance&quot;, &quot;0.049&quot;},\r\n            {&quot;Information Ratio&quot;, &quot;-14.565&quot;},\r\n            {&quot;Tracking Error&quot;, &quot;0.001&quot;},\r\n            {&quot;Treynor Ratio&quot;, &quot;1.97&quot;},\r\n            {&quot;Total Fees&quot;, &quot;$3.44&quot;},\r\n            {&quot;Estimated Strategy Capacity&quot;, &quot;$56000000.00&quot;},\r\n            {&quot;Lowest Capacity Asset&quot;, &quot;SPY R735QTJ8XC9X&quot;},\r\n            {&quot;Portfolio Turnover&quot;, &quot;19.93%&quot;},\r\n            {&quot;OrderListHash&quot;, &quot;0c0f9328786b0c9e8f88d271673d16c3&quot;}\r\n        };\r\n    }\r\n}\r\n","modified":"2024-03-26 13:17:35","projectId":17481097,"open":0,"isLibrary":false,"collaborationId":"P17481097-7a78b-75b7d-d7a3a-8fafa","userHasAccess":true,"readOnly":false}],"success":true}