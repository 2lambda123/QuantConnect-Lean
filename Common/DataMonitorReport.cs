/*
 * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
 * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

using Newtonsoft.Json;
using QuantConnect.Interfaces;
using QuantConnect.Util;
using System;
using System.Collections.Generic;
using System.Linq;

namespace QuantConnect
{
    /// <summary>
    /// Report generated by the <see cref="IDataMonitor"/> class that contains information about data requests
    /// </summary>
    [JsonConverter(typeof(DataMonitorReportJsonConverter))]
    public class DataMonitorReport
    {
        /// <summary>
        /// Paths of the files that were requested and successfully fetched
        /// </summary>
        public ISet<string> FetchedData { get; }

        /// <summary>
        /// Paths of the files that were requested but could not be fetched
        /// </summary>
        public ISet<string> MissingData { get; }

        /// <summary>
        /// Gets the number of data files that were fetched
        /// </summary>
        public int MissingDataCount
        {
            get { return MissingData.Count; }
        }

        /// <summary>
        /// Fets the percentage of data requests that could not be satisfied
        /// </summary>
        public double MissingDataPercentage
        {
            get
            {
                var requestsCount = FetchedData.Count + MissingData.Count;

                if (requestsCount == 0)
                {
                    return 0;
                }

                return MissingData.Count / (double)requestsCount * 100;
            }
        }

        /// <summary>
        /// Rates at which data requests were made per second
        /// </summary>
        public IEnumerable<double> DataRequestRates { get; }

        /// <summary>
        /// Universe data path that were requested and successfully fetched
        /// </summary>
        public IEnumerable<string> FetchedUniverseData
        {
            get { return GetUniverseDataPaths(FetchedData); }
        }

        /// <summary>
        /// Universe data paths that were requested but could not be fetched
        /// </summary>
        public IEnumerable<string> MissingUniverseData
        {
            get { return GetUniverseDataPaths(MissingData); }
        }

        /// <summary>
        /// Universe data paths that were requested and successfully fetched, grouped by security type
        /// </summary>
        public IEnumerable<IGrouping<string, string>> FetchedUniverseDataBySecurityType
        {
            get { return GetUniverseDataBySecurityType(FetchedData); }
        }

        /// <summary>
        /// Universe data paths that were requested and successfully fetched, grouped by market
        /// </summary>
        public IEnumerable<IGrouping<string, string>> FetchedUniverseDataByMarket
        {
            get { return GetUniverseDataByMarket(FetchedData); }
        }

        /// <summary>
        /// Universe data paths that were requested but could not be fetched, grouped by security type
        /// </summary>
        public IEnumerable<IGrouping<string, string>> MissingUniverseDataBySecurityType
        {
            get { return GetUniverseDataBySecurityType(MissingData); }
        }

        /// <summary>
        /// Universe data paths that were requested but could not be fetched, grouped by market
        /// </summary>
        public IEnumerable<IGrouping<string, string>> MissingUniverseDataByMarket
        {
            get { return GetUniverseDataByMarket(MissingData); }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataMonitorReport"/> class
        /// </summary>
        /// <param name="fetchedData">List of data paths that were requested and successfuly served</param>
        /// <param name="missingData">List of data paths that were requested but could not be served</param>
        /// <param name="dataRequestRates">Rates at which data requests were made per second</param>
        public DataMonitorReport(
            ISet<string> fetchedData,
            ISet<string> missingData,
            IEnumerable<double> dataRequestRates)
        {
            FetchedData = fetchedData;
            MissingData = missingData;
            DataRequestRates = dataRequestRates;
        }

        private static char[] _pathSeparators = new[] { '/', '\\' };

        /// <summary>
        /// Gets the universe data paths from the specified data paths
        /// </summary>
        private static IEnumerable<string> GetUniverseDataPaths(ISet<string> paths)
        {
            return paths.Where(path =>
            {
                var pathParts = path
                    .Split(_pathSeparators, StringSplitOptions.RemoveEmptyEntries)
                    // Skip file name
                    .SkipLast(1)
                    // Last two are either 'fundamental/coarse' or 'universe'
                    .TakeLast(2)
                    .ToArray();
                return (pathParts[0].Equals("fundamental", System.StringComparison.OrdinalIgnoreCase) &&
                        pathParts[1].Equals("coarse", System.StringComparison.OrdinalIgnoreCase)) ||
                       pathParts[1].Equals("universe", System.StringComparison.OrdinalIgnoreCase);
            });
        }

        /// <summary>
        /// Gets the universe data paths from the specified data paths, grouped by security type
        /// </summary>
        private static IEnumerable<IGrouping<string, string>> GetUniverseDataBySecurityType(ISet<string> paths)
        {
            return GetUniverseDataPaths(paths).GroupBy(path =>
            {
                var pathParts = path.Split(_pathSeparators, StringSplitOptions.RemoveEmptyEntries).ToList();
                return pathParts.Find(x => LeanData.SecurityTypeAsDataPath.Contains(x.ToLowerInvariant()));
            });
        }

        /// <summary>
        /// Gets the universe data paths from the specified data paths, grouped by market
        /// </summary>
        private static IEnumerable<IGrouping<string, string>> GetUniverseDataByMarket(ISet<string> paths)
        {
            return GetUniverseDataPaths(paths).GroupBy(path =>
            {
                var pathParts = path.Split(_pathSeparators, StringSplitOptions.RemoveEmptyEntries).ToList();
                var index = pathParts.FindIndex(x => LeanData.SecurityTypeAsDataPath.Contains(x.ToLowerInvariant()));
                return pathParts[index + 1];
            });
        }
    }
}
